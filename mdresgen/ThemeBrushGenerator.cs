using System.Collections;
using System.Diagnostics;
using System.Drawing;
using System.Net;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace mdresgen;

public record class Brush(
    [property:JsonPropertyName("name")]
    string? Name,
    [property:JsonPropertyName("themeValues")]
    ThemeValues ThemeValues,
    [property:JsonPropertyName("alternateKeys")]
    string[]? AlternateKeys)
{
    public const string BrushPrefix = "MaterialDesign.Brush.";
    public string PropertyName => Name!.Split(".")[^1];
    public string NameWithoutPrefix => Name![BrushPrefix.Length..];
    public string[] ContainerParts => Name!.Split('.')[2..^1];
    public string ContainerTypeName => string.Join('.', ContainerParts);
}


public record class ThemeValues(
    [property:JsonPropertyName("light")]
    string Light,
    [property:JsonPropertyName("dark")]
    string Dark);


[DebuggerDisplay($"{{{nameof(Name)}}} [Values: {{{nameof(Values)}.Count}}] [Children: {{{nameof(Children)}.Count}}]")]
public class TreeItem<T> : IEnumerable<T>
{
    public string Name { get; }

    public TreeItem(string name) => Name = name;

    public List<T> Values { get; } = new();

    public List<TreeItem<T>> Children { get; } = new();

    public IEnumerator<T> GetEnumerator()
    {
        foreach (T value in Values)
        {
            yield return value;
        }
        foreach(TreeItem<T> child in Children)
        {
            foreach (T value in child)
            {
                yield return value;
            }
        }
    }
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}

internal static class ThemeBrushGenerator
{
    private record class BrushContainer(string ClassName,

        BrushContainer[] Children);

    public static async Task Generate()
    {
        DirectoryInfo repoRoot = GetRepoRoot() ?? throw new InvalidOperationException("Failed to find the repo root");

        using var inputFile = File.OpenRead("Brushes.json");
        Brush[] brushes = await JsonSerializer.DeserializeAsync<Brush[]>(inputFile)
            ?? throw new InvalidOperationException("Did not find brushes from source file");
        brushes = brushes.OrderBy(x => x.Name).ToArray();

        TreeItem<Brush> brushTree = BuildBrushTree(brushes);

        GenerateThemeBrushFiles(brushes, repoRoot);
        GenerateThemeManager(brushTree, repoRoot);
        GenerateThemeFiles(brushes, repoRoot);
        GenerateBuiltinThemingDictionaries(brushes, repoRoot);
    }

    public static TreeItem<Brush> BuildBrushTree(IReadOnlyList<Brush> brushes)
    {
        TreeItem<Brush> root = new("");
        
        foreach (Brush brush in brushes)
        {
            TreeItem<Brush> current = root;
            foreach (string part in brush.ContainerParts)
            {
                TreeItem<Brush>? child = current.Children.FirstOrDefault(x => x.Name == part);
                if (child is null)
                {
                    child = new(part);
                    current.Children.Add(child);
                }
                current = child;
            }
            current.Values.Add(brush);
        }

        return root;
    }

    private static void GenerateThemeBrushFiles(IEnumerable<Brush> brushes, DirectoryInfo repoRoot)
    {
        var groupedBrushes = brushes.GroupBy(brush =>
        {
            if (brush.Name?.StartsWith(Brush.BrushPrefix) != true)
            {
                throw new InvalidOperationException($"Brush does not start with expected prefix \"{Brush.BrushPrefix}\" {brush}");
            }
            return brush.ContainerTypeName;
        });

        foreach (var brushGrouping in groupedBrushes)
        {
            string fileName;
            bool isRoot = false;
            if (string.IsNullOrEmpty(brushGrouping.Key))
            {
                fileName = "Theme.g.cs";
                isRoot = true;
            }
            else
            {
                fileName = $"Theme.{brushGrouping.Key}.g.cs";
            }
            //TODO: Write header to file indicating it is generated by this tool
            using var themeFile = new StreamWriter(Path.Combine(repoRoot.FullName, "MaterialDesignThemes.Wpf", "Theming", fileName));
            themeFile.WriteLine("using System.Windows.Media;");
            themeFile.WriteLine();
            themeFile.WriteLine("namespace MaterialDesignThemes.Wpf.Theming;");
            themeFile.WriteLine("");

            //className = $"{brushGrouping.Key}Brushes";
            themeFile.WriteLine($"public partial class Theme");
            themeFile.WriteLine("{");
            string indent = "    ";
            if (!isRoot)
            {
                themeFile.WriteLine($"    public sealed partial class {brushGrouping.Key.Replace(".", "")}Brushes");
                themeFile.WriteLine("    {");
                indent = "        ";
            }


            themeFile.WriteLine();

            foreach (Brush brush in brushGrouping)
            {
                themeFile.WriteLine($"{indent}public Color {brush.PropertyName} {{ get; set; }}");
                themeFile.WriteLine();
            }

            if (!isRoot)
            {
                themeFile.WriteLine("    }");
            }
            themeFile.WriteLine("}");
        }
    }

    private static void GenerateThemeManager(TreeItem<Brush> brushes, DirectoryInfo repoRoot)
    {
        using var themeManagerFile = new StreamWriter(Path.Combine(repoRoot.FullName, "MaterialDesignThemes.Wpf", "Theming", "ThemeManager.g.cs"));

        themeManagerFile.WriteLine("namespace MaterialDesignThemes.Wpf.Theming;");
        themeManagerFile.WriteLine();

        themeManagerFile.WriteLine("partial class ThemeManager");
        themeManagerFile.WriteLine("{");
        themeManagerFile.WriteLine();

        //Generate SetThemeBrushes
        themeManagerFile.WriteLine("    private static void SetThemeBrushes(ResourceDictionary resourceDictionary, Theme theme)");
        themeManagerFile.WriteLine("    {");
        foreach (var brush in brushes)
        {
            themeManagerFile.WriteLine($"        SetSolidColorBrush(resourceDictionary, \"{brush.Name}\", theme.{brush.NameWithoutPrefix});");
        }
        themeManagerFile.WriteLine("    }");

        themeManagerFile.WriteLine();

        // Generate GetThemeBrushes
        themeManagerFile.WriteLine("    private static Theme GetThemeBrushes(ResourceDictionary resourceDictionary)");
        themeManagerFile.WriteLine("    {");
        themeManagerFile.WriteLine($"        return new Theme");
        themeManagerFile.WriteLine("        {");
        const string indent = "        ";

        void WriteTreeItem(TreeItem<Brush> treeItem, string indent)
        {
            if (!string.IsNullOrEmpty(treeItem.Name))
            {
                themeManagerFile.WriteLine($"{indent}{treeItem.Name} =");
                themeManagerFile.WriteLine($"{indent}{{");
            }

            WriteValues(treeItem, indent + "    ");

            foreach (TreeItem<Brush> child in treeItem.Children)
            {
                WriteTreeItem(child, indent + "    ");
            }

            if (!string.IsNullOrEmpty(treeItem.Name))
            {
                themeManagerFile.WriteLine($"{indent}}},");
            }
        }

        void WriteValues(TreeItem<Brush> treeItem, string indent)
        {
            foreach (Brush brush in treeItem.Values)
            {
                themeManagerFile.WriteLine($"{indent}{brush.PropertyName} = GetColor(resourceDictionary, \"{brush.Name}\"),");
            }
        }

        WriteTreeItem(brushes, indent);
        
        themeManagerFile.WriteLine("        };");
        themeManagerFile.WriteLine("    }");
        
        themeManagerFile.WriteLine();
        themeManagerFile.WriteLine("}");
    }

    private static void GenerateThemeFiles(IEnumerable<Brush> brushes, DirectoryInfo repoRoot)
    {
        WriteFile("LightTheme", b => b.ThemeValues.Light);
        WriteFile("DarkTheme", b => b.ThemeValues.Dark);

        void WriteFile(string className, Func<Brush, string> getThemeValue)
        {
            using var writer = new StreamWriter(Path.Combine(repoRoot.FullName, "MaterialDesignThemes.Wpf", "Theming", $"{className}.g.cs"));
            writer.WriteLine("using System.Windows.Media;");
            writer.WriteLine();
            writer.WriteLine("namespace MaterialDesignThemes.Wpf.Theming;");
            writer.WriteLine();
            
            writer.WriteLine($"partial class {className}");
            writer.WriteLine("{");
            writer.WriteLine($"    public {className}()");
            writer.WriteLine("    {");
            ColorConverter converter = new();
            foreach (Brush brush in brushes)
            {
                string themeValue = getThemeValue(brush);
                Color colorValue = (Color)converter.ConvertFromString(themeValue)!;
                writer.WriteLine($"        {brush.NameWithoutPrefix} = Color.FromArgb(0x{colorValue.A:X}, 0x{colorValue.R:X}, 0x{colorValue.G:X}, 0x{colorValue.B:X});");
            }
            writer.WriteLine("    }");
            writer.WriteLine("}");
        }
    }

    private static void GenerateBuiltinThemingDictionaries(IEnumerable<Brush> brushes, DirectoryInfo repoRoot)
    {
        WriteFile("BundledTheme");
        WriteFile("CustomColorTheme");

        void WriteFile(string className)
        {
            using var writer = new StreamWriter(Path.Combine(repoRoot.FullName, "MaterialDesignThemes.Wpf", $"{className}.g.xaml"));
            writer.WriteLine($"<ResourceDictionary x:Class=\"MaterialDesignThemes.Wpf.{className}\"");
            writer.WriteLine("                    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"");
            writer.WriteLine("                    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\">");
            writer.WriteLine();

            const string indent = "  ";
            foreach (Brush brush in brushes)
            {
                writer.WriteLine($"{indent}<SolidColorBrush x:Key=\"{brush.Name}\" />");
                writer.WriteLine($"{indent}<Color x:Key=\"{brush.Name}.Color\" />");
            }

            writer.WriteLine();
            writer.WriteLine($"{indent}<!-- Obsolete -->");
            
            foreach (Brush brush in brushes)
            {
                foreach(string alternateKey in brush.AlternateKeys ?? Enumerable.Empty<string>())
                {
                    writer.WriteLine($"{indent}<SolidColorBrush x:Key=\"{alternateKey}\" />");
                    writer.WriteLine($"{indent}<Color x:Key=\"{alternateKey}Color\" />");
                }
            }

            writer.WriteLine("</ResourceDictionary>");
        }
    }

    private static DirectoryInfo? GetRepoRoot()
    {
        DirectoryInfo? currentDirectory = new DirectoryInfo(Environment.CurrentDirectory);
        while (currentDirectory is { } && !currentDirectory.EnumerateDirectories(".git").Any())
        {
            currentDirectory = currentDirectory.Parent;
        }
        return currentDirectory;
    }
}
