using System.Drawing;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace mdresgen;

public record class Brush(
    [property:JsonPropertyName("name")]
    string? Name,
    [property:JsonPropertyName("themeValues")]
    ThemeValues ThemeValues,
    [property:JsonPropertyName("alternateKeys")]
    string[]? AlternateKeys)
{
    public const string BrushPrefix = "MaterialDesign.Brush.";
    public string PropertyName => Name!.Split(".")[^1];
    public string NameWithoutPrefix => Name![BrushPrefix.Length..];
    public string[] ContainerParts => Name!.Split('.')[2..^1];
    public string ContainerTypeName => string.Join('.', ContainerParts);
}


public record class ThemeValues(
    [property:JsonPropertyName("light")]
    string Light,
    [property:JsonPropertyName("dark")]
    string Dark);

internal static class ThemeBrushGenerator
{
    private record class BrushContainer(string ClassName,

        BrushContainer[] Children);

    public static async Task Generate()
    {
        DirectoryInfo repoRoot = GetRepoRoot() ?? throw new InvalidOperationException("Failed to find the repo root");

        using var inputFile = File.OpenRead("Brushes.json");
        Brush[] brushes = await JsonSerializer.DeserializeAsync<Brush[]>(inputFile)
            ?? throw new InvalidOperationException("Did not find brushes from source file");

        GenerateThemeBrushFiles(brushes, repoRoot);
        GenerateThemeManager(brushes, repoRoot);
        GenerateThemeFiles(brushes, repoRoot);
        GenerateBuiltinThemingDictionaries(brushes, repoRoot);
    }

    private static void GenerateThemeBrushFiles(IEnumerable<Brush> brushes, DirectoryInfo repoRoot)
    {
        var groupedBrushes = brushes.GroupBy(brush =>
        {
            if (brush.Name?.StartsWith(Brush.BrushPrefix) != true)
            {
                throw new InvalidOperationException($"Brush does not start with expected prefix \"{Brush.BrushPrefix}\" {brush}");
            }
            return brush.ContainerTypeName;
        });

        foreach (var brushGrouping in groupedBrushes)
        {
            string fileName;
            bool isRoot = false;
            if (string.IsNullOrEmpty(brushGrouping.Key))
            {
                fileName = "Theme.g.cs";
                isRoot = true;
            }
            else
            {
                fileName = $"Theme.{brushGrouping.Key}.g.cs";
            }
            //TODO: Write header to file indicating it is generated by this tool
            using var themeFile = new StreamWriter(Path.Combine(repoRoot.FullName, "MaterialDesignThemes.Wpf", "Theming", fileName));
            themeFile.WriteLine("using System.Windows.Media;");
            themeFile.WriteLine();
            themeFile.WriteLine("namespace MaterialDesignThemes.Wpf.Theming;");
            themeFile.WriteLine("");

            //className = $"{brushGrouping.Key}Brushes";
            themeFile.WriteLine($"public partial class Theme");
            themeFile.WriteLine("{");
            string indent = "    ";
            if (!isRoot)
            {
                themeFile.WriteLine($"    public sealed partial class {brushGrouping.Key}Brushes");
                themeFile.WriteLine("    {");
                indent = "        ";
            }


            themeFile.WriteLine();

            foreach (Brush brush in brushGrouping)
            {
                themeFile.WriteLine($"{indent}public Color {brush.PropertyName} {{ get; set; }}");
                themeFile.WriteLine();
            }

            if (!isRoot)
            {
                themeFile.WriteLine("    }");
            }
            themeFile.WriteLine("}");
        }
    }

    private static void GenerateThemeManager(IEnumerable<Brush> brushes, DirectoryInfo repoRoot)
    {
        using var themeManagerFile = new StreamWriter(Path.Combine(repoRoot.FullName, "MaterialDesignThemes.Wpf", "Theming", "ThemeManager.g.cs"));

        themeManagerFile.WriteLine("namespace MaterialDesignThemes.Wpf.Theming;");
        themeManagerFile.WriteLine();

        themeManagerFile.WriteLine("partial class ThemeManager");
        themeManagerFile.WriteLine("{");
        themeManagerFile.WriteLine();

        //Generate SetThemeBrushes
        themeManagerFile.WriteLine("    private static void SetThemeBrushes(ResourceDictionary resourceDictionary, Theme theme)");
        themeManagerFile.WriteLine("    {");
        foreach (var brush in brushes)
        {
            themeManagerFile.WriteLine($"        SetSolidColorBrush(resourceDictionary, \"{brush.Name}\", theme.{brush.NameWithoutPrefix});");
        }
        themeManagerFile.WriteLine("    }");

        themeManagerFile.WriteLine();

        // Generate GetThemeBrushes
        themeManagerFile.WriteLine("    private static Theme GetThemeBrushes(ResourceDictionary resourceDictionary)");
        themeManagerFile.WriteLine("    {");
        themeManagerFile.WriteLine($"        return new Theme");
        themeManagerFile.WriteLine("        {");
        const string indent = "            ";
        foreach (var brush in brushes)
        {
            string currentIndent = indent;
            foreach(string part in brush.ContainerParts)
            {
                themeManagerFile.WriteLine($"{currentIndent}{part} =");
                themeManagerFile.WriteLine($"{currentIndent}{{");
                currentIndent += "    ";
            }
            themeManagerFile.WriteLine($"{currentIndent}{brush.PropertyName} = GetColor(resourceDictionary, \"{brush.Name}\"),");
            foreach (string _ in brush.ContainerParts)
            {
                currentIndent = currentIndent[..^4];
                themeManagerFile.WriteLine($"{currentIndent}}}");
            }
        }
        themeManagerFile.WriteLine("        };");
        themeManagerFile.WriteLine("    }");



        themeManagerFile.WriteLine();
        themeManagerFile.WriteLine("}");



        /*
         * partial class ThemeManager
{
    private void SetBrushes(ResourceDictionary resourceDictionary, Theme theme)
    {
        SetSolidColorBrush(resourceDictionary, "MaterialDesign.Brush.Background", theme.Background);
    }
}
         */
    }

    private static void GenerateThemeFiles(IEnumerable<Brush> brushes, DirectoryInfo repoRoot)
    {
        WriteFile("LightTheme", b => b.ThemeValues.Light);
        WriteFile("DarkTheme", b => b.ThemeValues.Dark);

        void WriteFile(string className, Func<Brush, string> getThemeValue)
        {
            using var writer = new StreamWriter(Path.Combine(repoRoot.FullName, "MaterialDesignThemes.Wpf", "Theming", $"{className}.g.cs"));
            writer.WriteLine("using System.Windows.Media;");
            writer.WriteLine();
            writer.WriteLine("namespace MaterialDesignThemes.Wpf.Theming;");
            writer.WriteLine();
            
            writer.WriteLine($"partial class {className}");
            writer.WriteLine("{");
            writer.WriteLine($"    public {className}()");
            writer.WriteLine("    {");
            ColorConverter converter = new();
            foreach (Brush brush in brushes)
            {
                string themeValue = getThemeValue(brush);
                Color colorValue = (Color)converter.ConvertFromString(themeValue)!;
                writer.WriteLine($"        {brush.NameWithoutPrefix} = Color.FromArgb(0x{colorValue.A:X}, 0x{colorValue.R:X}, 0x{colorValue.G:X}, 0x{colorValue.B:X});");
            }
            writer.WriteLine("    }");
            writer.WriteLine("}");
        }
    }

    private static void GenerateBuiltinThemingDictionaries(IEnumerable<Brush> brushes, DirectoryInfo repoRoot)
    {
        WriteFile("BundledTheme");
        WriteFile("CustomColor");

        void WriteFile(string className)
        {
            using var writer = new StreamWriter(Path.Combine(repoRoot.FullName, "MaterialDesignThemes.Wpf", $"{className}.g.xaml"));
            writer.WriteLine($"<ResourceDictionary x:Class=\"MaterialDesignThemes.Wpf.{className}\"");
            writer.WriteLine("                    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"");
            writer.WriteLine("                    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\">");
            writer.WriteLine();

            const string indent = "  ";
            foreach (Brush brush in brushes)
            {
                writer.WriteLine($"{indent}<SolidColorBrush x:Key=\"{brush.Name}\" />");
                writer.WriteLine($"{indent}<Color x:Key=\"{brush.Name}.Color\" />");
            }

            writer.WriteLine();
            writer.WriteLine($"{indent}<!-- Obsolete -->");
            
            foreach (Brush brush in brushes)
            {
                foreach(string alternateKey in brush.AlternateKeys ?? Enumerable.Empty<string>())
                {
                    writer.WriteLine($"{indent}<SolidColorBrush x:Key=\"{alternateKey}\" />");
                    writer.WriteLine($"{indent}<Color x:Key=\"{alternateKey}Color\" />");
                }
            }

            writer.WriteLine("</ResourceDictionary>");
        }
    }

    private static DirectoryInfo? GetRepoRoot()
    {
        DirectoryInfo? currentDirectory = new DirectoryInfo(Environment.CurrentDirectory);
        while (currentDirectory is { } && !currentDirectory.EnumerateDirectories(".git").Any())
        {
            currentDirectory = currentDirectory.Parent;
        }
        return currentDirectory;
    }
}
